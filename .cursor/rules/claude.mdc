---
alwaysApply: true
---
# Dev Philosophy

We are not to be working or developing code features in parallel - Not in chat, nor with code development.
Code development will be incremental - One feature at a time, one step at a time.
Develop each feature/tool sequentially - Complete each fully and test with gates before moving to the next steps.

# Market Sector Sentiment Analysis Tool - Code Guidelines

## üéØ SDD Alignment - CRITICAL

### **SDD-1 (MUST)** Check SDD Before & After Every Function
- **BEFORE WRITING**: Review `SDD` to ensure your planned function aligns with the sector-first architecture
- **AFTER WRITING**: Verify your implementation preserves the multi-timeframe sector analysis workflow while adding new capabilities
- **CORE PRINCIPLE**: Enhance, Don't Replace - preserve Sector Grid ‚Üí Multi-Timeframe Analysis ‚Üí Stock Rankings pipeline
- **MODULAR FOCUS**: Ensure your function fits the modular architecture (services/, mcp/, agents/, components/)

### **SDD-2 (MUST)** Preserve Sector-First Architecture Integrity
- Never break the proven 8-sector grid with multi-timeframe analysis (30min, 1D, 3D, 1W)
- Maintain top 3 bullish/bearish stock rankings per sector
- Keep extended hours operation (4 AM - 8 PM ET)
- Ensure real-time WebSocket updates with 30-minute refresh cycles

---

## Implementation Best Practices

### 0 ‚Äî Purpose

These rules ensure maintainability, safety, and developer velocity for the Market Sector Sentiment Analysis Tool.
**MUST** rules are enforced by testing; **SHOULD** rules are strongly recommended.

---

### 1 ‚Äî Before Coding - BP = Best Practices

- **BP-1 (MUST)** Ask the user clarifying questions.
- **BP-2 (SHOULD)** Draft and confirm an approach for complex work.
- **BP-3 (SHOULD)** If ‚â• 2 approaches exist, list clear pros and cons.
- **BP-4 (MUST)** Review Market Sector Sentiment Analysis SDD for alignment with sector-first architecture.

---

### 2 ‚Äî While Coding

- **C-1 (MUST)** Follow TDD: scaffold stub -> write failing test -> implement.
- **C-2 (MUST)** Name functions with existing domain vocabulary for consistency (sector, timeframe, sentiment, shortability).
- **C-3 (SHOULD NOT)** Introduce classes when small testable functions suffice.
- **C-4 (SHOULD)** Prefer simple, composable, testable functions.
- **C-5 (MUST)** Use proper Python type hints for all function parameters and return values
  ```python
  def calculate_sector_sentiment(symbols: List[str], timeframe: str) -> SectorSentiment:  # ‚úÖ Good
  def calculate_sector_sentiment(symbols, timeframe):  # ‚ùå Bad
  ```
- **C-6 (MUST)** Use proper imports and avoid circular dependencies.
- **C-7 (SHOULD NOT)** Add docstrings except for critical caveats; rely on self‚Äëexplanatory code.
- **C-8 (SHOULD)** Use Pydantic models for structured financial data (SectorSentiment, StockData, etc.).
- **C-9 (SHOULD NOT)** Extract a new function unless it will be reused elsewhere, is the only way to unit-test otherwise untestable logic, or drastically improves readability of an opaque block.
- **C-10 (MUST)** Follow modular architecture: place code in appropriate modules (services/, mcp/, agents/, components/).

---

### 3 ‚Äî Testing

- **T-1 (MUST)** For a simple function, colocate unit tests in `test_*.py` files in same directory as source file.
- **T-2 (MUST)** For any financial data change, add/extend integration tests in `tests/integration/`.
- **T-3 (MUST)** ALWAYS separate pure-logic unit tests from external API-touching integration tests.
- **T-4 (SHOULD)** Prefer integration tests over heavy mocking for Polygon.io API and database operations.
- **T-5 (SHOULD)** Unit-test complex financial algorithms (sector sentiment calculation, multi-timeframe analysis) thoroughly.
- **T-6 (SHOULD)** Use pytest fixtures for common test data and setup.
- **T-7 (MUST)** Test financial data integration without breaking existing sector analysis workflow.

---

### 4 ‚Äî Database & External Services

- **D-1 (MUST)** Use proper async/await patterns for Polygon.io API calls and market data processing.
- **D-2 (SHOULD)** Implement proper rate limiting and retry logic for external financial API calls.
- **D-3 (MUST)** Use PostgreSQL + TimescaleDB client properly for time-series financial data storage.
- **D-4 (MUST)** Use Redis caching for sector sentiment data consistently.
- **D-5 (SHOULD)** Implement proper error handling for API failures and network issues during market hours.

---

### 5 ‚Äî Code Organization

- **O-1 (MUST)** Place shared utilities in `services/` only if used by ‚â• 2 modules.
- **O-2 (MUST)** Keep MCP-specific code in `mcp/` module.
- **O-3 (MUST)** Place AI agent orchestration code in `agents/` module.
- **O-4 (MUST)** Keep React components in `components/` module.
- **O-5 (SHOULD)** Follow Python package structure with proper `__init__.py` files.

---

### 6 ‚Äî Tooling Gates

- **G-1 (MUST)** `black --check` passes for code formatting.
- **G-2 (MUST)** `flake8` or `ruff` passes for linting.
- **G-3 (MUST)** `mypy` passes for type checking.
- **G-4 (MUST)** `pytest` passes for all tests.

---

### 7 - Git

- **GH-1 (MUST)** Use Conventional Commits format when writing commit messages: https://www.conventionalcommits.org/en/v1.0.0
- **GH-2 (SHOULD NOT)** Refer to Claude or Anthropic in commit messages.

---

## Writing Functions Best Practices

When evaluating whether a function you implemented is good or not, use this checklist:

1. **SDD ALIGNMENT**: Does this function align with the sector-first architecture? Does it preserve multi-timeframe analysis workflow integrity?
2. Can you read the function and HONESTLY easily follow what it's doing? If yes, then stop here.
3. Does the function have very high cyclomatic complexity? (number of independent paths, or, in a lot of cases, number of nesting if if-else as a proxy). If it does, then it's probably sketchy.
4. Are there any common data structures and algorithms that would make this function much easier to follow and more robust? Parsers, trees, stacks / queues, etc.
5. Are there any unused parameters in the function?
6. Are there any unnecessary type casts that can be moved to function arguments?
7. Is the function easily testable without mocking core features (e.g. Polygon.io API, database, sector calculations)? If not, can this function be tested as part of an integration test?
8. Does it have any hidden untested dependencies or any values that can be factored out into the arguments instead? Only care about non-trivial dependencies that can actually change or affect the function.
9. Brainstorm 3 better function names and see if the current name is the best, consistent with rest of codebase.
10. **MODULAR ARCHITECTURE**: Is the function in the correct module (services/, mcp/, agents/, components/)?

IMPORTANT: you SHOULD NOT refactor out a separate function unless there is a compelling need, such as:

- the refactored function is used in more than one place
- the refactored function is easily unit testable while the original function is not AND you can't test it any other way
- the original function is extremely hard to follow and you resort to putting comments everywhere just to explain it

## Writing Tests Best Practices

When evaluating whether a test you've implemented is good or not, use this checklist:

1. **SDD ALIGNMENT**: Does this test verify functionality that aligns with the sector-first architecture? Does it test the preserved multi-timeframe workflow?
2. SHOULD parameterize inputs; never embed unexplained literals such as 42 or "AAPL" directly in the test.
3. SHOULD NOT add a test unless it can fail for a real defect. Trivial asserts (e.g., assert 2 == 2) are forbidden.
4. SHOULD ensure the test description states exactly what the final assert verifies. If the wording and assert don't align, rename or rewrite.
5. SHOULD compare results to independent, pre-computed expectations or to properties of the domain, never to the function's output re-used as the oracle.
6. SHOULD follow the same lint, type-safety, and style rules as prod code (black, flake8, mypy).
7. SHOULD express invariants or axioms (e.g., commutativity, idempotence, round-trip) rather than single hard-coded cases whenever practical. Use `hypothesis` library for property-based testing:

```python
from hypothesis import given, strategies as st
import pytest
from your_module import calculate_sector_sentiment

@given(st.lists(st.text(min_size=1), min_size=1))
def test_sector_sentiment_preserves_length_property(stock_symbols):
    """Test that sector sentiment calculation preserves basic properties."""
    result = calculate_sector_sentiment(stock_symbols, "1D")
    assert -1.0 <= result.sentiment_score <= 1.0
    assert 0.0 <= result.confidence <= 1.0
```

8. Unit tests for a function should be grouped under `class TestFunctionName` or use descriptive test file names.
9. Use `pytest.fixture` for common test data and setup.
10. ALWAYS use strong assertions over weaker ones e.g. `assert x == 1` instead of `assert x >= 1`.
11. SHOULD test edge cases, realistic input, unexpected input, and value boundaries.
12. SHOULD NOT test conditions that are caught by the type checker.
13. **INTEGRATION TESTS**: Test financial API integration and database interactions with proper mocking.


## Remember Shortcuts

Remember the following shortcuts which the user may invoke at any time.

### QNEW

When I type "qnew", this means:

```
Understand all BEST PRACTICES listed in this document.
Your code SHOULD ALWAYS follow these best practices.
CRITICAL: Review Market Sector Sentiment Analysis SDD before writing any new code.
```

### QPLAN

When I type "qplan", this means:

```
Analyze similar parts of the codebase and determine whether your plan:
- is consistent with rest of codebase
- introduces minimal changes
- reuses existing code
- aligns with sector-first architecture
- preserves multi-timeframe analysis workflow integrity
```

## QCODE

When I type "qcode", this means:

```
Implement your plan and make sure your new tests pass.
Always run tests to make sure you didn't break anything else.
Always run `black` on the newly created files to ensure standard formatting.
Always run `flake8` and `mypy` to make sure linting and type checking passes.
CRITICAL: Verify implementation aligns with Market Sector Sentiment Analysis SDD.
```

### QCHECK

When I type "qcheck", this means:

```
You are a SKEPTICAL senior software engineer.
Perform this analysis for every MAJOR code change you introduced (skip minor changes):

1. Market Sector Sentiment Analysis SDD alignment check - does this preserve sector-first workflow?
2. This document checklist Writing Functions Best Practices.
3. This document checklist Writing Tests Best Practices.
4. This document checklist Implementation Best Practices.
```

### QCHECKF

When I type "qcheckf", this means:

```
You are a SKEPTICAL senior software engineer.
Perform this analysis for every MAJOR function you added or edited (skip minor changes):

1. Market Sector Sentiment Analysis SDD alignment check - does this enhance without replacing?
2. This document checklist Writing Functions Best Practices.
```

### QCHECKT

When I type "qcheckt", this means:

```
You are a SKEPTICAL senior software engineer.
Perform this analysis for every MAJOR test you added or edited (skip minor changes):

1. This document checklist Writing Tests Best Practices.
2. Does this test verify SDD alignment and sector-first workflow preservation?
```

### QUX

When I type "qux", this means:

```
Imagine you are a human UX tester of the Market Sector Sentiment Analysis feature you implemented.
Output a comprehensive list of scenarios you would test, sorted by highest priority.
Consider both the sector dashboard workflow and multi-timeframe analysis scenarios.
```

### QGIT

When I type "qgit", this means:

```
Add all changes to staging, create a commit, and push to remote.

Follow this checklist for writing your commit message:
- SHOULD use Conventional Commits format: https://www.conventionalcommits.org/en/v1.0.0
- SHOULD NOT refer to Claude or Anthropic in the commit message.
- SHOULD structure commit message as follows:
<type>[optional scope]: <description>
[optional body]
[optional footer(s)]
- commit SHOULD contain the following structural elements to communicate intent:
fix: a commit of the type fix patches a bug in your codebase (this correlates with PATCH in Semantic Versioning).
feat: a commit of the type feat introduces a new feature to the codebase (this correlates with MINOR in Semantic Versioning).
BREAKING CHANGE: a commit that has a footer BREAKING CHANGE:, or appends a ! after the type/scope, introduces a breaking API change (correlating with MAJOR in Semantic Versioning). A BREAKING CHANGE can be part of commits of any type.
types other than fix: and feat: are allowed, for example @commitlint/config-conventional (based on the Angular convention) recommends build:, chore:, ci:, docs:, style:, refactor:, perf:, test:, and others.
footers other than BREAKING CHANGE: <description> may be provided and follow a convention similar to git trailer format.
```